// Noise Generation Algorithm taken from "The Book of Shaders"
// https://thebookofshaders.com/11/

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "/Engine/Private/PostProcessCommon.ush"

float4 Color;
float2 ScreenDimensions;
RWTexture2D<float4> OutputTexture;
float Time;

float2 random2(float2 st){
    st = float2( dot(st,float2(127.1,311.7)),
              dot(st,float2(269.5,183.3)) );
    return -1.0 + 2.0*frac(sin(st)*43758.5453123);
}

// Gradient Noise by Inigo Quilez - iq/2013
// https://www.shadertoy.com/view/XdXGW8
float noise(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);

    float2 u = f*f*(3.0-2.0*f);

    return lerp( lerp( dot( random2(i + float2(0.0,0.0) ), f - float2(0.0,0.0) ),
                     dot( random2(i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                lerp( dot( random2(i + float2(0.0,1.0) ), f - float2(0.0,1.0) ),
                     dot( random2(i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
}

[numthreads(8, 8, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
    if (DispatchThreadId.x >= ScreenDimensions.x || DispatchThreadId.y >= ScreenDimensions.y)
	return;

    float2 st = DispatchThreadId.xy / ScreenDimensions.xy;
    st.x *= ScreenDimensions.x / ScreenDimensions.y;
    float3 color = float3(0.0, 0.0, 0.0);

    float t = abs(1.0 - sin(Time * 0.1)) * 5.0;

    st += noise(st * 2.0) * t; // Animate the coordinate space
    color = float3(1.0, 1.0, 1.0) * smoothstep(0.18, 0.2, noise(st)); // Big black drops
    color += smoothstep(.15,.2,noise(st*10.)); // Black splatter
    color -= smoothstep(.35,.4,noise(st*10.)); // Holes on splatter
    
    OutputTexture[DispatchThreadId.xy] = float4(color, 1.0);
}